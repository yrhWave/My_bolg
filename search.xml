<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring]]></title>
    <url>%2FSpring%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[Spring总结Spring简介 Spring是一个开源的设计层面框架，它解决的是业务逻辑层和其他层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson创建。简单来说，Spring是一个分层的JavaSE/EE full-stack(一栈式) 轻量级开源框架。 J2EE三层架构体系 表现层 view，典型代表：Strusts，Spring MVC 业务层 Service，主要功能是业务处理、功能逻辑、事务控制 IOC、AOP 持久层 dao，mybatis、hibernate、jdbc 轻量级Spring的出现取代了EJB的臃肿、低效、繁琐复杂、脱离现实。 Spring体系结构 IOCIOC介绍 IOC其是一种设计思想，将创建对象的权利交给Spring，由IOC统一加载和管理，让Spring去管理对象生命周期，极大的解决了程序耦合性高的问题。 IOC思想前瞻IOC的核心思想在于，资源不由使用资源的双方管理，而由不使用资源的第三方管理，这可以带来很多好处： 资源集中管理，实现资源的可配置和易管理 降低了使用资源双方的依赖程度，也就是我们说的耦合度。比如说甲方要达成某种目的不需要直接依赖乙方，它只需要达到的目的告诉第三方机构就可以了。 举个栗子： ​ 比如甲方需要一双袜子，而乙方它卖一双袜子它要把袜子卖出去，并不需要自己去直接找到一个买家来完成袜子的卖出。它也只需要找第三方，告诉别人我要卖一双袜子。这样甲乙双方进行交易活动，都不需要自己直接去找卖家，相当于程序内部开放接口，卖家由第三方作为参数传入。甲乙互相不依赖，而且只有在进行交易活动的时候，甲才和乙产生联系。反之亦然。 ​ 这样做什么好处么呢？甲乙可以在对方不真实存在的情况下独立存在，而且保证不交易时候无联系，想交易的时候可以很容易的产生联系。甲乙交易活动不需要双方见面，避免了双方的互不信任造成交易失败的问题。因为交易由第三方来负责联系，而且甲乙都认为第三方可靠。那么交易就能很可靠很灵活的产生和进行了，这就是IOC的核心思想甲乙双方将不在相互依懒！ Spring IOC 容器 Spring IOC容器有两种BeanFactory和ApplicationContext，BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身。ApplicationContext 面向使用 Spring 框架的开发者，几乎所有的应用场合我们都直接使用 ApplicationContext 而非底层的 BeanFactory。 BeanFactory BeanFactory 接口位于类结构树的顶端 ，IOC容器所设定的最基本功能规范。 BeanFactory最主要的方法就是getBean(String beanName)，这个方法从容器中返回特别名称的Bean。 BeanFactory的三个子接口： HierarchicalBeanFactory：提供父容器的访问功能 ListableBeanFactory：提供了批量获取Bean的方 AutowireCapableBeanFactory：在BeanFactory基础上实现对已存在实例的管解析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public interface BeanFactory &#123; /** * 获取产生对象的FactoryBean * 如：myObject是一个FactoryBean，使用&amp;myObject得到的是FactoryBean */ String FACTORY_BEAN_PREFIX = "&amp;"; /** * 获取IoC容器中管理的bean * @param name * @return * @throws BeansException */ Object getBean(String name) throws BeansException; /** * 判断容器是否含有指定名称的bean * @param name * @return */ boolean containsBean(String name); /** * 检查指定名称的bean是否是单例（可以在BeanDefinition中指定） * @param name * @return * @throws NoSuchBeanDefinitionException */ boolean isSingleton(String name) throws NoSuchBeanDefinitionException; /** * 检查指定名称的bean是否是prototype类型（可以在BeanDefinition中指定） * @param name * @return * @throws NoSuchBeanDefinitionException */ boolean isPrototype(String name) throws NoSuchBeanDefinitionException; /** * 检查指定名称的bean的Class类型是否是特定Class类型 * @param name * @param targetType 用户指定 * @return * @throws NoSuchBeanDefinitionException */ boolean isTypeMatch(String name, Class targetType) throws NoSuchBeanDefinitionException; /** * 查询指定名称bean的Class类型 * @param name * @return * @throws NoSuchBeanDefinitionException */ Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; /** * 查询指定名称bean的所有别名（用户在BeanDefinition中指定的） * @param name * @return */ String[] getAliases(String name);&#125; ApplicationContext12ApplicationContext app = new ClassPathXmlApplicationContext("配置文件.xml"); 类名 对象名 =(类名)app.getBean(" "); 从 ApplicationContext 的继承机构可以看到，ApplicationContext 继承了BeanFactory，也就是说，ApplicationContext拥有BeanFactory的全部功能。ApplicationContext 是通过将容器的功能委派给DefaultListableBeanFactory来实现。除了继承BeanFactory，还有ResourceLoader、EnvironmentCapable、ApplicationEventPublisher、MessageSource等接口，也就说明ApplicationContext 除了容器的功能外，还囊括了资源的处理、环境、事件发布、国际化等。 示例12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 若没写id，则默认为com.test.Man#0,#0为一个计数形式 --&gt; &lt;bean id="man" class="com.test.Man"&gt;&lt;/bean&gt;&lt;/beans&gt;public class Test &#123; public static void main(String[] args) &#123; //加载项目中的spring配置文件到容器 //ApplicationContext context = new ClassPathXmlApplicationContext("resouces/applicationContext.xml"); //加载系统盘中的配置文件到容器 ApplicationContext context = new FileSystemXmlApplicationContext("E:/Spring/applicationContext.xml"); //从容器中获取对象实例 Man man = context.getBean(Man.class); man.driveCar(); &#125;&#125; DI(依赖注入) IOC重点是如何在系统运行中动态向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。 比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 Spring我们就只需要告诉Spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，Spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由 Spring注入到A中的，依赖注入的名字就这么来的。 那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，Spring就是通过反射来实现注入的。 DI关键点理解DI的关键是：依赖。为什么需要依赖，谁注入谁，注入了什么。 应用程序依赖于IOC容器，为什么需要依赖：应用程序需要IOC容器来提供对象需要的外部资源比如对数据库操作的对象，IOC容器注入这个，应用程序依赖这个对象 IOC和DI有什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：依赖注入，相对IOC 而言，依赖注入明确描述了被注入对象依赖IOC容器配置依赖对象！ Spring装配bean的三种方式 构造器注入 使用setter方法注入（推荐） 接口注入 基于注解的方式1234567891011121314@Component：可以用于注册所有bean@Repository：主要用于注册dao层的bean@Controller： 主要用于注册控制层的bean@Service： 主要用于注册服务层的bean@Resource：java的注解，默认以byName的方式去匹配与属性名相同的bean的id，如果没有找到就会以byType的方式查找，如果byType查找到多个的话，使用@Qualifier注解（spring注解）指定某个具体名称的bean。@Autowired：spring注解，默认也是以byName的方式去匹配与属性名相同的bean的id，如果没有找到，就通过byType的方式去查找，如果查找到多个，用@Qualifier注解限定具体使用哪个。@Autowiredprivate IUserDao userDao;但是如果IUserDao有多个实现类则需要：@Autowired@Qualifier("指定具体实现")private IUserDao userDao; AOP 在软件业，AOP为Aspect Oriented Programming的缩写，意为：[面向切面编程]，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，使函数式编程降低，提高程序的可重用性，同时提高了开发的效率。 ![aop场景](https://ronghua-yu-blog.oss-cn-beijing.aliyuncs.com/图床/blog/spring aop 场景.png) spring术语 切面：拦截器类，其中会定义切点以及通知 通知：切面中的方法，包括： 前置通知：在动态代理反射原先方法前调用的方法 后置通知：在动态代理反射完原有方法后调用的方法 返回通知：如果方法正常执行，在调用完后置通知后，就调用返回通知 异常通知：如果方法出现异常，在调用完后置通知后，就调用异常通知 环绕通知：可以决定是否调用目标方法，同时可以控制方法的返回 对象 引入：往代理对象中添加新的方法，但是新的方法不会被拦截 切点：即定义需要拦截的方法的特征，可以通过正则表达式匹配，也可以通过类的全限定名 连接点：需要拦截的方法 织入：生成代理对象并将切面内容嵌入流程中，将切面内容嵌入到流程中是什么意思呢？例如现在定义了前置通知，那么代理对象在调用被代理对象的方法之前就会调用前置通知 示例12345678910111213141516171819202122232425@Aspectpublic class UserInterceptor &#123; @Pointcut("execution( * org.srm.practice.service.*.*(..))") public void user() &#123; &#125; @Before("user()") public void sayHello() &#123; System.out.println("前置"); &#125; @After("user()") public void sayGoodbey() &#123; System.out.println("后置"); &#125; @Around("user()") public void sayAround(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println("环绕通知..环绕前"); pjp.proceed();//执行方法 System.out.println("环绕通知..环绕后"); &#125;&#125; 事物 Spring支持编程式事务管理和声明式事务管理两种方式。 编程式事务编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，Spring推荐使用TransactionTemplate。 声明式事务声明式事务管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中 事务隔离级别 隔离级别是指若干个并发的事务之间的隔离程度。 TransactionDefinition 接口中定义了五个表示隔离级别的常量： TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。 TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。 TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。 TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。 TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 事务传播级别 所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。 在TransactionDefinition定义中包括了如下几个表示传播行为的常量： TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。 TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。 TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。 TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 TransactionDefinition.PROPAGATION_REQUIRED。 事务超时,所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。默认设置为底层事务系统的超时值，如果底层数据库事务系统没有设置超时值，那么就是none，没有超时限制。]]></content>
      <categories>
        <category>java学习笔记</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud]]></title>
    <url>%2FSpring%20Cloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html</url>
    <content type="text"><![CDATA[Spring Cloud Spring Cloud 微服务架构 Spring Cloud 网关 Spring Cloud 服务发现 Spring Cloud 其他组件 Spring Cloud 微服务架构什么是微服务 集群：通过一组集成得计算机软件和/或硬件连接起来高度紧密得协作完成计算机工作。 高性能:通过多台计算机完成统一工作，分摊压力，达到跟高得效率 高可用：两机或多机工作内容、过程完全一致，可以互相顶替 分布式：一组计算机通过网络互相连接传递消息与通信并协调他们之间的行为而形成得系统，组件之间彼此进行交互以实现一个共同得目标 低耦合：模块之间相互独立，便于扩展，提高资源利用效率 高吞吐：功能差分，分散到不同得模块执行 集群和分布式并不冲突 CAP理论：强一致性（C）、极致可用性（A）、分区容错性（P） 什么是 Spring Cloud​ 当我们了解集群和分布式这两个概念之后，我们来看看什么是Spring Cloud，在这之前我们先回顾一下Spring Boot，Spring Boot是比较合适基于spring的快速开发，用于搭建一个单体的小型项目非常方便。这里为什么提Spring boot呢？因为Spring Cloud就是基于Spring Boot实现的。 Spring Cloud提供了分布式系统的一整套的解决方案 Spring Cloud提供了快速构建分布式系统中的一些常见模式的组件 ps：前面对集群和分布式讲解是从概念上进行理解的，当我们落实到实现上时，可能会约到各种各样的问题，随着分布式架构的发展，慢慢的有一些优秀的架构设计，还有一些组件就会被广泛的应用，Spring Cloud就为常见的架构提供一些通用的组件。 Spring Cloud 组件下面我们通过一个图来了解Spring Cloud为分布式系统提供的组件 服务​ 假设我们需要利用Spring Boot开发一个单独的系统，但是随着我们系统的开发，一个单体的应用程序可能会变得非常的臃肿，整个应用程序会变得非常庞大，代码量和功能都会变得很多。这时我们按照分布式的概念将服务进行拆分，如上图，此时出现了橙、蓝、黄三个服务，每个服务只专注自己的功能。 注册中心​ 但是当我们拆分为多个服务之后，服务之间难免会出现互相通信的时候，这个时候我们可能需要在服务中去维护其他服务的ip，这就略显麻烦了。当我们在服务器集群中使用容器化部署的时候我们就会遇到一个更加灾难性的问题——我们每次部署的ip可能会变化，那么这个ip的维护工作就会变得非常繁琐。为了解决这个问题，Spring Cloud提供了一个组件叫注册中心，有了注册中心这个组件之后，每个服务不再像之前一样在服务内去维护其他服务的ip，而是将自己的ip维护到注册中心，这样注册中心就会有一个完整的服务列表，如果需要进行服务间的调用，我们只需要去注册中心拉去服务列表，去获取对应服务的ip就可以了。 负载均衡——Ribbon​ 解决了最基本的通信问题之后，随着系统的不断扩展，我们会发现即使服务进行了划分，我们某个服务可能会遇到性能上的瓶颈，这时我们想到一个办法——将调用比较频繁的服务进行集群部署。例如上图，将第一个服务部署成两个节点，此时系统的压力会得到一定的缓解。但是这个时候我们又遇到了一个新的问题——服务件调用的时候我们需要进行一个决策。例如第二个服务和第三个服务需要调用第一个服务，但是第一个服务有两个节点，我们需要对集群的调用做负载均衡，不然调用请求集中发到一个节点上，这样还是会导致这个节点服务器压力特别大。这个时候，Spring Cloud为我们提供了一个组件——Ribbon，这个组件就是为了处理一个服务多实例下的负载均衡。 熔断限流——Hystrix​ 当我们有了负载均衡之后，我们的系统能正常运行，但是这样还不够，比如我们做了集群和负载均衡，第一个服务的压力还是非常大，这时服务间的调用可能会有阻塞，当服务调用发生了阻塞，又无节制的去向第一个服务发送请求，很可能会导致第一个服务宕机。Spring Cloud为了避免这种情况为我们提供了一个新的组件——Hystrix。这个组件的功能是熔断和限流，也就是当我们的请求无法得到响应的时候，它会中断我们的请求，并限制我们的请求调用，通过这种机制我们就能避免系统长时间无响应、服务器压力过高。 API网关​ 在有了熔断和限流之后，我们系统的内部组件已经比较完整了，但这时我们又会遇到一个微服务带来的问题——用户通过web端或客户端访问我们的系统时，它需要访问多个服务，此时我们就需要在web端或者客户端去维护我们多个服务的服务信息，这与服务去维护其他服务信息一样，是非常让人头疼的。除了这个问题之外，我们还会遇到另一个问题，通常情况下，我们的系统都系统做认证和授权，针对这种分布式的场景，每个服务还需要自己去实现权限校验的功能，也就是说无形中，我们分布式系统实现的代价就高了。为了解决这个问题，Spring Cloud引入了一个组件——API网关，API网关也是注册到注册中心，它的功能就是统一对外的入口，请求不再访问指定的服务，而是同意从网关访问，网关会通过一系列的过滤，最终将请求转发到对应的服务上。 授权服务​ 我们可以统一入口，那么我们也可以做一些其他的统一操作，比如授权，我们可以在网关中添加权限过滤，这样就不需要在每个服务中单独做服务校验了。 Spring Cloud 常用组件通过上面的介绍，我们了解了 Spring Cloud 为我们提供的一些组件，也了解了 Spring Cloud 的架构，下面我们进行总结： 服务治理：Spring Cloud Eureka 负载均衡：Spring Cloud Ribbon 熔断限流：Spring Cloud Hystrix 服务调用：Spring Cloud Feign 发起一个请求，原始的情况是使用httpclient，或者是采用spring封装过的resttemplate，但是这两个还是相对比较繁琐的，Feign的存在就是为了简化内部调用，它提供了声明性来提供内部调用，不需要自己再去实现http请求，我们只需要定义一个接口，它就能自动帮我们封装成一个http请求，Feign的实现也是基于resttemplate 网关服务：Spring Cloud Zuul]]></content>
      <categories>
        <category>java学习笔记</category>
      </categories>
      <tags>
        <tag>springCloud</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello Hexo]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
