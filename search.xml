<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计算机网络之OSI七层模型]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BOSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.html</url>
    <content type="text"><![CDATA[计算机网络之OSI七层模型OSI开放式互联参考模型 当前市面上存在着四层、五层、七层协议，而国际标准化组织ISO指定的OSI七层协议模型是业界提出来的概念性框架。整个模型分为七层，物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。 物理层为了解决两台物理机之间的通信需求，具体就是机器A往机器B放松比特流，机器B能收到比特流，这便是物理层需要做的工作。 物理层主要定义了物理设备的标准，如网线的类型，光纤接口的类型，各种传输介质的传输速率等。 它的主要作用是传输比特流，即我们所说的“010101”这样的二进制数据，将它们转化为电流强弱进行传输，到达目的地后再转化为二进制数据，这就是数模转换和模数转换。 物理层的数据称为比特，网卡就是工作在物理层。 数据链路层在传输比特流的过程中，会发生错传、传输不完整的情况，因此，数据链路层应运而生。 数据链路层定义了如何格式化数据进行传输，以及对物理介质的访问，通常还提供错误检查和纠正，以确保数据传输的可靠性。 本层将比特数据组成了帧，交换机在这一层工作，对帧进行接码，并将帧中的数据发送到正确的接收方。 网络层随着网络节点的不断增加，点对点通讯时是需要经过多个节点的，那么如何找到目标节点?如何选择最佳路径？这戏问题成了首要需求，所以便有了网络层。 网络层的主要功能是将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方。网络层会综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费，来决定从一个网络中节点A到另一个网络中节点B的最佳路径。 网络层的数据称为数据包。由于网络层处理并智能知道数据传送，路由器连接网络各端，所以路由器属于网络层。 在这一层里我们需要注意TCP/IP协议里的IP协议。 传输层随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据，如海量文件传输等，这可能需要很长的时间，而网络在通信的过程中是会中断很多次的，此时为了保证传输大量文件的准确性，需要对发送出去的数据进行切分，切分为一个一个的段落，即segment，进行发送。那么其中一个段落丢失了该怎么办？要不要重发？每个段落要按照顺序达到吗？这些便是传输层需要考虑的问题。 传输层解决了数据间的传输，数据间的传输可以是不同网络的。传输层解决了数据传输的质量问题，该层是OSI模型中最重要的一层。 传输协议同时进行流量控制，或是基于接收方接收数据的快慢程度，规定适当的发送速率。除此之外，传输层按照网络能处理的最大尺寸，将较长的数据包进行强制分割，例如以太网无法接收大于1500字节的数据包，发送方的传输层将数据分割成较小的数据片，同时对每个数据片编号，以便数据到达接收方的传输层时能以正确的顺序重组，这个过程称为排序。 传输层需要关注的协议有TCP协议和UDP协议。 会话层现在我们已经保证给正确的接受方发送正确封装过后的信息，但是我们每次调用TCP去打包，然后调用IP协议去找路由，自己去发吗？答案当然是否定的，所以我们要建立一个自动收发包，一个自动寻址的功能，于是发明了会话层。 会话层的作用就是建立和管理应用程序之间的通信。 表示层不同操作系统之间通信语法是不同的，这个时候就需要表示层来帮我们解决这个问题。 在表示层，数据将按照网络能理解的方案进行格式化，这种格式化也因使用网络类型的不同而不同。 应用层此时发送方虽然知道自己发送的是什么东西，转换成字节数组后有多长，但接受方肯定不知道。所以应用层诞生了。 它规定消息的发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，而且消息头里必须记录消息体的长度等一些列信息，方便接收方能正确解析数据，应用层旨在让你更方便地应用在网络中接收到的数据，对于数据的传递，没有该层也可以完成，只不过传输的都是由1和0组成的字节数组。 这一层需要我们重点关注的时http协议。 OSI开放式互联网参考模型先自上而下，后自下而上处理数据头部从应用层开始，都会对要传输的数据头部进行处理，加上本层的一些信息，最终物理层通过以太网电缆等介质将数据解析成比特流，在网络中传输。 数据传输到目标地址，并自下而上地将数据头部进行分离、解析。 TCP/IPOSI的“实现”：TCP/IP TCP/IP也是先自上而下，后自下而上处理头部数据。]]></content>
      <categories>
        <category>JAVA学习笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高并发之Synchronized]]></title>
    <url>%2F%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8BSynchronized.html</url>
    <content type="text"><![CDATA[高并发之SynchronizedSynchronized简介Synchronized的作用官方解释Synchronized methods enable a simple strategy for preventing thread interference and memory consistency errors:if an object is visible to more than one thread,all reads or writes to that object’s variables are done through synchronized methods. 一句话说出Synchronized的作用能够保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果。 Synchronized的地位 Synchronized是Java的一个关键字 是最基本的互斥同步的手段 是并发编程中的元老级角色，是并发编程的必学内容不用并发手段的后果代码实战：两个线程同事a++,最后结果会比预期少1234567891011121314151617181920212223242526272829/** * @program: concurrency_demo * @Author: RONGHUA.YU@HAND-CHINA.COM * @Date: 2019/9/17 15:14 * @Description: 高并发之消失的请求，两个线程对i++，执行100000次，结果一定小于200000 */public class DisappearRequest1 implements Runnable&#123; static DisappearRequest1 disappearRequest1 = new DisappearRequest1(); static int i = 0; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(disappearRequest1); Thread t2 = new Thread(disappearRequest1); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(i); &#125; @Override public void run() &#123; for (int j = 0; j &lt; 100000; j++) &#123; i++; &#125; &#125;&#125; 运行结果： 1132889 原因：count++，它看上去只是一个操作，实际上包含了三个动作： 读取count 将count加一 将count的值写道内存中这三个动作执行到任何一个动作时，都有可能被打断，如此时count为9，线程a执行到+1操作，count的值变为10.但是还没来得及写入内存，线程b就开始执行，此时读取到的count依然是9，这和我们的预期就不同了，我们称之为线程不安全 Synchronized的两种用法Synchronized的两种用法介绍对象锁，包括方法锁（默认锁对象为this当前实例对象）和同步代码块锁（自己指定锁对象） 类锁，指synchronized修饰静态的方法或指定锁为Class对象 第一个用法：对象锁代码块锁 代码块形式：手动指定锁对象 锁对象的选取：若不特定锁对象，可以用this（当前对象）作为我们的锁。 但有时候情况比较复杂，需要我们自己去选取锁对象，比如我们有多个个synchronized代码块，不是它们其中一个执行其它的就不能执行，而是可以同步执行，如下例，定义了两个Object类型的对象作为我们的锁，此时代码运行就可以是两两配对地运行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @program: concurrency_demo * @Author: RONGHUA.YU@HAND-CHINA.COM * @Date: 2019/9/12 14:08 * @Description: 对象锁示例一：代码块锁 */public class SynchronizedObjectCodeBlock2 implements Runnable &#123; static SynchronizedObjectCodeBlock2 instance = new SynchronizedObjectCodeBlock2(); final Object lock1 = new Object(); final Object lock2 = new Object(); @Override public void run() &#123; //代码块形式 synchronized (lock1) &#123; System.out.println("我是lock1。我叫" + Thread.currentThread().getName()); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "lock1运行结束"); &#125; synchronized (lock2) &#123; System.out.println("我是lock2。我叫" + Thread.currentThread().getName()); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "lock2运行结束"); &#125; &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); while(t1.isAlive()||t2.isAlive())&#123; &#125; System.out.println("finished"); &#125;&#125; 运行结果： 123456789我是lock1。我叫Thread-0Thread-0lock1运行结束我是lock2。我叫Thread-0我是lock1。我叫Thread-1Thread-1lock1运行结束Thread-0lock2运行结束我是lock2。我叫Thread-1Thread-1lock2运行结束finished 除了这种情况，可能还有更复杂的情形，比如三个线程等待一个线程，再比如线程之间还有通信，就很难处理了，可能通过我们自己的努力也是能写出来，但是不建议自己写，因为如果稍有疏忽，就可能出现比较大的错误，那怎么去避免？实际上jdk为我们提交了几个非常完善的同步控制工具类，例如CountDownLatch、CyclicBarrier、Semaphore、Exchanger等等，有兴趣的可以去了解。 方法锁形式 synchronized修饰普通方法（非静态方法），锁对象默认为this 12345678910111213141516171819202122232425262728293031323334353637/** * @program: concurrency_demo * @Author: RONGHUA.YU@HAND-CHINA.COM * @Date: 2019/9/12 14:08 * @Description: 对象锁示例二：方法锁 */public class SynchronizedObjectMethod3 implements Runnable &#123; static SynchronizedObjectMethod3 instance = new SynchronizedObjectMethod3(); @Override public void run() &#123; method(); &#125; private synchronized void method() &#123; System.out.println("我是对象锁的方法修饰符形式，我叫" + Thread.currentThread().getName()); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "运行结束"); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("finished"); &#125;&#125; 运行结果： 12345我是对象锁的方法修饰符形式，我叫Thread-1Thread-1运行结束我是对象锁的方法修饰符形式，我叫Thread-0Thread-0运行结束finished 第二个用法：类锁类锁的概念概念：Java类可能有很多对象，但只有一个Class对象 本质：所谓的类锁，就是Class对象的锁 用法和效果：类锁在同一时刻只能被一个对象拥有 形式一：synchronized加在static方法上 形式二：synchronized（*.class）代码块 例如有一个student类，它可以创造出很多个实例，例如小明同学、小美同学， 但是在Java中万物皆对象，对于这个类这个class它也是个对象，这个对象只有一个，也就是说无论是小明还是小美，他们是这个对象的实例，但他们都会有一个对应的这个类的对象，而这个对象（类对象）只有一个，不会实例化很多个出来。 本质：不同的实例不同的线程，它们去访问用类锁的方法的时候，所获取到的那把锁其实是class对象，而且class对象只有一个，所以不论是哪个实例过来的线程，他们能获取到这唯一的一个锁，也就是说，类锁是一个概念上的东西，它并不是真实存在的有这个一个类锁，它这个概念是为了帮我们理解实例方法和静态方法的区别的。class对象从本质上来说也是一个Java对象，只不过这个对象很特殊，这时我们就应该明白了，所谓的类锁本质上是将class对象作为我们的锁，而由于它只有一个，所以不同的实例之间会互斥，只有一个线程在同一时刻访问被类锁锁住的方法。 类锁的第一种形式 synchronized加载static方法上 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @program: concurrency_demo * @Author: RONGHUA.YU@HAND-CHINA.COM * @Date: 2019/9/18 10:37 * @Description: 类锁的第一种形式：static形式 */public class SynchronizedClassStatic4 implements Runnable &#123; static SynchronizedClassStatic4 instance1 = new SynchronizedClassStatic4(); static SynchronizedClassStatic4 instance2 = new SynchronizedClassStatic4(); @Override public void run() &#123; method(); &#125; /** * 这里的method方法上加了static，此时线程0和线程1会串行，如果将static去掉，线程0和1将会串行 * 所以如果我们需要在全局的情况下同步这个方法，不仅仅是一个对象等小层面，我们可以用下面这种形式 */ private static synchronized void method()&#123; System.out.println("我是类锁的第一种形式：static形式，我叫"+Thread.currentThread().getName()); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+"执行结束"); &#125; public static void main(String[] args) &#123; //两个不同实例的线程 Thread t1 = new Thread(instance1); Thread t2 = new Thread(instance2); t1.start(); t2.start(); while(t1.isAlive()||t2.isAlive())&#123; &#125; System.out.println("finished"); &#125;&#125; 运行结果： 12345我是类锁的第一种形式：static形式，我叫Thread-0Thread-0执行结束我是类锁的第一种形式：static形式，我叫Thread-1Thread-1执行结束finished 这里我们新建SynchronizedClassStatic4类，并创建出两个实例instance1和instance2，不同实例的线程去调用被synchronized修饰的static方法。不同实例去访问synchronized修饰的方法，如果这个方法不是static的话，线程还是会并行的，加上static，可以做到全局的同步。 类锁的第二种形式 synchronized(*.class) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @program: concurrency_demo * @Author: RONGHUA.YU@HAND-CHINA.COM * @Date: 2019/9/18 11:11 * @Description: 类锁的第二种形式：synchronized(*.class) */public class SynchronizedClassClass5 implements Runnable&#123; static SynchronizedClassClass5 instance1 = new SynchronizedClassClass5(); static SynchronizedClassClass5 instance2 = new SynchronizedClassClass5(); @Override public void run() &#123; method(); &#125; private void method()&#123; //可以试试将下面的SynchronizedClassClass5.class换成this //换成this后，不同实例的线程来访问时，还是会并行 synchronized (SynchronizedClassClass5.class)&#123; //在这个synchronized里面包含的代码执行起来，它的锁对象就会是SynchronizedClassClass5.class这个对象 //所以无论哪个实例运用的都是同一个对象,所以无论是本例中的instance1还是instance2，执行到这里时，都需要拿到锁才能执行 System.out.println("我是类锁的第二种形式：synchronized(*.class),我叫" +Thread.currentThread().getName()); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+"执行完毕"); &#125; &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance1); Thread t2 = new Thread(instance2); t1.start(); t2.start(); while(t1.isAlive()||t2.isAlive())&#123; &#125; System.out.println("finished"); &#125;&#125; 运行结果： 12345我是类锁的第二种形式：synchronized(*.class),我叫Thread-1Thread-1执行完毕我是类锁的第二种形式：synchronized(*.class),我叫Thread-0Thread-0执行完毕finished 我们可以看到，在本例 method 方法中的 synchronized 代码块，它标明的锁是 可以试试将下面的 SynchronizedClassClass5.class 换成 this 或者是 *.class （其他类，并不是直接写 *.class）。换成 this 后，不同实例的线程来访问时，还是会并行；换成 *.class 的话，能到达一样的串行效果。 在这个 synchronized 里面包含的代码执行起来，它的锁对象就会是 SynchronizedClassClass5.class 这个对象，所以无论哪个实例运用的都是同一个对象,所以无论是本例中的 instance1 还是 instance2 ，执行到这里时，都需要拿到锁才能执行。 多线程访问同步方法的7种情况1. 两个线程同事访问一个对象的同步方法两个线程依次执行，锁生效 2. 两个线程访问的是两个对象的同步方法此时synchronized不生效，两个线程并行执行 3. 两个线程访问的是synchronized的静态方法两个线程依次执行，锁生效 4. 同时访问同步方法与非同步方法代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @program: concurrency_demo * @Author: RONGHUA.YU@HAND-CHINA.COM * @Date: 2019/9/18 16:08 * @Description: 同时访问同步方法和非同步方法 */public class SynchronizedYesAndNo6 implements Runnable&#123; static SynchronizedYesAndNo6 instance = new SynchronizedYesAndNo6(); @Override public void run() &#123; if("Thread-0".equals(Thread.currentThread().getName()))&#123; method1(); &#125;else&#123; method2(); &#125; &#125; public synchronized void method1()&#123; System.out.println("我是枷锁方法，我叫"+Thread.currentThread().getName()); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+"运行结束"); &#125; public void method2()&#123; System.out.println("我是不枷锁方法，我叫"+Thread.currentThread().getName()); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+"运行结束"); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("finished"); &#125;&#125; 运行结果： 12345我是不枷锁方法，我叫Thread-1我是枷锁方法，我叫Thread-0Thread-0运行结束Thread-1运行结束finished 从这里可以看出来synchronized关键字只作用于我们指定的被修饰的方法中，对于其他没加修饰符的方法，不会受到影响。 访问同一个对象的不同的普通同步方法代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @program: concurrency_demo * @Author: RONGHUA.YU@HAND-CHINA.COM * @Date: 2019/9/18 16:23 * @Description: 同时访问一个类两个不同的普通同步方法 */public class SynchronizedDifferentMethod7 implements Runnable&#123; static SynchronizedDifferentMethod7 instance = new SynchronizedDifferentMethod7(); @Override public void run() &#123; if("Thread-0".equals(Thread.currentThread().getName()))&#123; method1(); &#125;else&#123; method2(); &#125; &#125; public synchronized void method1()&#123; System.out.println("同步方法1，我叫"+Thread.currentThread().getName()); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+"运行结束"); &#125; public synchronized void method2()&#123; System.out.println("同步方法2，我叫"+Thread.currentThread().getName()); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+"运行结束"); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("finished"); &#125;&#125; 运行结果： 12345同步方法1，我叫Thread-0Thread-0运行结束同步方法2，我叫Thread-1Thread-1运行结束finished 在这个例子中，虽然没指明锁对象，本质上其实是默认为指定 this 这个对象作为它的这把锁，所以对于同一个实例 instance 来讲，两个方法 method1 和 method2 拿到的锁是一样的，所以这两个方法没办法同时运行。 同时访问静态synchronized和非静态的synchronized方法代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @program: concurrency_demo * @Author: RONGHUA.YU@HAND-CHINA.COM * @Date: 2019/9/18 16:47 * @Description: 同时访问静态synchronized和非静态的synchronized方法 */public class SynchronizedStaticAndNormal8 implements Runnable&#123; static SynchronizedStaticAndNormal8 instance = new SynchronizedStaticAndNormal8(); @Override public void run() &#123; if("Thread-0".equals(Thread.currentThread().getName()))&#123; method1(); &#125;else&#123; method2(); &#125; &#125; public synchronized static void method1()&#123; System.out.println("静态加锁方法1，我叫"+Thread.currentThread().getName()); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+"运行结束"); &#125; public synchronized void method2()&#123; System.out.println("非静态加锁方法2，我叫"+Thread.currentThread().getName()); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+"运行结束"); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("finished"); &#125;&#125; 运行结果： 12345静态加锁方法1，我叫Thread-0非静态加锁方法2，我叫Thread-1Thread-0运行结束Thread-1运行结束finished 这里Thread-0和Thread-1几乎是同时运行同时结束的。为什么呢？ 在这个例子中的method1方法，就是我们前面提到的类锁的第一种形式，它的锁对象是类的class对象；在method2方法中，是我们前面提到的对象锁的方法锁形式，即synchronized修饰普通方法（不可为静态方法），锁对象默认为 this。锁不同，当然可以同时拿到两把锁，然后同时访问了。 方法抛异常后，会释放锁区别与lock，synchronized修饰的方法抛异常后，会释放锁，而lock不会自动释放，需要通过unLock()去释放，具体lock和synchronized的区别可以自行去查询一些资料，或者关注我的后续更新，我们先来看看synchronized抛异常释放锁的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @program: concurrency_demo * @Author: RONGHUA.YU@HAND-CHINA.COM * @Date: 2019/9/18 17:15 * @Description: 方法抛异常，自动释放锁，展示不抛出异常前和抛出异常后的对比：一旦抛出异常，第二个线程会立刻进入同步方法，意味着锁已经释放。 */public class SynchronizedException9 implements Runnable&#123; static SynchronizedException9 instance = new SynchronizedException9(); @Override public void run() &#123; if("Thread-0".equals(Thread.currentThread().getName()))&#123; method1(); &#125;else&#123; method2(); &#125; &#125; public synchronized void method1()&#123; System.out.println("加锁方法1，我叫"+Thread.currentThread().getName()); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; throw new RuntimeException();// System.out.println(Thread.currentThread().getName()+"运行结束"); &#125; public synchronized void method2()&#123; System.out.println("加锁方法2，我叫"+Thread.currentThread().getName()); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+"运行结束"); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("finished"); &#125; 运行结果： 12345678加锁方法1，我叫Thread-0加锁方法2，我叫Thread-1Exception in thread &quot;Thread-0&quot; java.lang.RuntimeException at demo.SynchronizedException9.method1(SynchronizedException9.java:28) at demo.SynchronizedException9.run(SynchronizedException9.java:15) at java.lang.Thread.run(Thread.java:745)Thread-1运行结束finished 在这个例子的method1方法中抛出了一个运行时异常，我们没在这里做任何释放锁的操作，Thread-0抛出异常后，Thread-1就拿到了锁并执行，这时因为由synchronized修饰的方法抛出异常后，jvm会自动地帮我们释放锁，然后下一个线程就可以正常运行了。 总结：3点核心思想 一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待（对应第1、5种情况）； 每个实例都对应有自己的一把锁，不同实例之间互不影响；例外：锁对象是 *.class 以及synchronized 修饰的是 static 方法的时候，所有的对象共用同一把锁（对应2、3、4、6种情况） 无论是方法正常执行或者方法抛出异常，都会释放锁（对应第7种情况） 思考：加入一个线程进入到一个被synchronized修饰的方法，再这个方法种又调用了一个没有被synchronized修饰的方法，此时还是线程安全的吗？ Synchronized的性质可重入性质什么是可重入指的是统一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁 一个线程拿到一把锁，下次需要用锁的时候，可以直接拿到，就是可重入的；如果拿到锁之后，想再次使用，此时不可直接再次拿到，必须和其他线程一起竞争，这就是不可重入的，可重入锁也称递归锁。 好处避免死锁、提升封装性 那么它又是如何避免死锁的？ 假设有两个被 synchronized 修饰的方法A和B，线程0访问了A方法，这个时候，线程0又想要去访问B方法，如果 synchronized 不具备可重入性，那么现在线程0想去访问B方法，它不能直接使用已经拿到的锁，需要拿锁，但它又没释放锁，就陷入了死锁状态了。 粒度可理解为范围，线程而非调用（用三种情况来说明和pthread的区别） 我们先假设我们不知道synchronized的粒度是线程的，我们一步一步探索： 情况一：证明同一个方法是可重入的 12345678910111213141516171819202122232425/** * @program: concurrency_demo * @Author: RONGHUA.YU@HAND-CHINA.COM * @Date: 2019/9/18 19:31 * @Description: 可重入粒度测试：递归调用本方法 */public class SynchronizedRecursion10 &#123; //定义一个a来标识执行次数 private int a = 0 ; public static void main(String[] args) &#123; SynchronizedRecursion10 synchronizedRecursion10 = new SynchronizedRecursion10(); synchronizedRecursion10.method(); &#125; private synchronized void method() &#123; //输出a来看看执行次数 System.out.println("a的值为："+a); //开始时a为0，满足判断，a++后值为1，再次调用就不满足了，所以method方法执行了两次 if(a==0)&#123; a++; method(); &#125; &#125;&#125; 运行结果： 12a的值为：0a的值为：1 情况二：证明可重入不要求是同一个方法 12345678910111213141516171819202122/** * @program: concurrency_demo * @Author: RONGHUA.YU@HAND-CHINA.COM * @Date: 2019/9/18 19:43 * @Description: 可重入粒度测试：调用类内另外的方法 */public class SynchronizedOtherMethod11 &#123; private synchronized void method1()&#123; System.out.println("我是method1"); method2(); &#125; private synchronized void method2() &#123; System.out.println("我是method2"); &#125; public static void main(String[] args) &#123; SynchronizedOtherMethod11 synchronizedOtherMethod11 = new SynchronizedOtherMethod11(); synchronizedOtherMethod11.method1(); &#125;&#125; 运行结果： 12我是method1我是method2 情况三：证明可重入不要求是同一个类 12345678910111213141516171819202122232425/** * @program: concurrency_demo * @Author: RONGHUA.YU@HAND-CHINA.COM * @Date: 2019/9/18 20:00 * @Description: 可重入粒度测试：调用父类方法 */public class SynchronizedSuperClass12 &#123; public synchronized void doSomeThing()&#123; System.out.println("我是父类方法"); &#125;&#125;class TestClass extends SynchronizedSuperClass12&#123; @Override public synchronized void doSomeThing()&#123; System.out.println("我是子类方法"); super.doSomeThing(); &#125; public static void main(String[] args) &#123; TestClass testClass = new TestClass(); testClass.doSomeThing(); &#125;&#125; 运行结果： 12我是子类方法我是父类方法 通过三种情况的探索，我们可以证明synchronized的粒度是线程。 当一个线程，执行时拿到了一把锁，如果此时它需要去执行另一个方法，且这个方法需要的锁依然是该线程手中的这把锁，那么synchronized可重入的性质就会被激发出来，就不需要显式的去释放锁或者重新获取锁。 不可中断性质 一旦这个锁已经被别人获取，如果我还想获得，我只能选择等待或者阻塞，直到别的线程释放这个锁。乳沟别人永远不释放，那么我只能永远等待下去。 深入原理 加锁和释放锁的原理：现象、时机、深入JVM看字节码 可重入原理：加锁次数计数器 保证可见性的原理：内存模型 加锁和释放锁的原理现象每一个类的实例对应着一把锁，而每一个synchronized方法都必须首先获得调用该方法的类的实例的锁，方能执行，否则线程会阻塞，而方法一旦执行了它就独占了这把锁，直到该方法返回或者是抛出异常，才将锁释放，释放之后，之前那些阻塞的线程才能获得这把锁，重新进入到可执行的状态。 也就意味着，当一个类中，有synchronized修饰的方法或代码块时，想要执行这个方法或者代码块，就必须先获得对应的对象锁，如果这个对象锁已经被其他线程占用，就必须等待到它被释放。所用的Java对象都含有一个互斥锁，由jvm自动地获取和释放，我们只需要指定这个对象就可以了，至于锁的获取和释放不需要我们操心。 获取和释放的时机：内置锁 每一个java对象都可以用作一个实现同步的锁，被称为内置锁，或者成为监视器锁（monitor lock）。 线程在进入同步方法或者代码块之前，会自动获得这把锁，并且在推出时会自动释放，无论是正常退出还是抛出异常退出都会释放。获取这个锁的唯一途径就是进入这个锁所保护的同步方法或者同步代码块之中。 等价代码我们用代码来模拟锁获取和释放的时机： 12345678910111213141516171819202122232425262728293031323334import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @program: concurrency_demo * @Author: RONGHUA.YU@HAND-CHINA.COM * @Date: 2019/9/19 9:34 * @Description: */public class SynchronizedToLock13 &#123; private Lock lock = new ReentrantLock(); public synchronized void method1()&#123; System.out.println("我是synchronized形式的锁"); &#125; public void method2()&#123; //加锁 lock.lock(); try&#123; System.out.println("我是lock形式的锁"); &#125;finally &#123; //释放锁 lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; SynchronizedToLock13 synchronizedToLock13 = new SynchronizedToLock13(); synchronizedToLock13.method1(); synchronizedToLock13.method2(); &#125;&#125; 运行结果： 12我是synchronized形式的锁我是lock形式的锁 在本例中，method1和method2其实是等价的，lock形式的锁需要显式的去加锁和释放锁，synchronized形式的锁是隐式的。synchronized形式的锁在执行开始时，jvm会自动地执行monitorenter，这就是加锁的动作，在抛出异常或者正常退出时，jvm会自动地执行monitorexit，monitorexit可能会有多个，因为释放锁的情况也有多个，后面我们会提到。 反编译看monitor指令如何反编译我们先编写一个简单的类，里面是同步代码块的形式： 123456789101112131415/** * @program: concurrency_demo * @Author: RONGHUA.YU@HAND-CHINA.COM * @Date: 2019/9/19 9:50 * @Description: 反编译字节码 */public class Decompilation14 &#123; private final Object object = new Object(); public void inster(Thread thread)&#123; synchronized(object)&#123; &#125; &#125;&#125; 打开命令行 win+r ,并利用javac编译 1javac Decompilation14.java 此时会生成一个class文件，再利用javap反编译 1javap -verbose Decompilation14.class //-verbose表示将所有的信息都打印 反编译并打印出信息，我们截取我们需要的部分 12345678910111213141516171819public void inster(java.lang.Thread); descriptor: (Ljava/lang/Thread;)V flags: ACC_PUBLIC Code: stack=2, locals=4, args_size=2 0: aload_0 1: getfield #3 // Field object:Ljava/lang/Object; 4: dup 5: astore_2 6: monitorenter 7: aload_2 8: monitorexit 9: goto 17 12: astore_3 13: aload_2 14: monitorexit 15: aload_3 16: athrow 17: return 我们可以看到地6行的monitorenter，以及第8、14的monitorexit，这就是我们前面提到的synchronized的隐式加锁、释放锁。 Monitorenter和Monitorexit指令 Monitorenter和Monitorexit指令在执行的时候，会让锁计数器+1或-1 这个操作和操作系统中的PV操作很像，PV就是来用控制多线程对于临界资源的访问的。 Monitorenter 实际上每一个对象都与一个monitor相关联，而一个monitor的lock锁在同一时间只能被一个线程获得，一个线程在尝试获取与对象关联的monitor的所有权的时候，只有以下三种情况： 锁计数器当前为0，表示这把锁还没有被占用，此时线程就会立刻拿到锁，并将monitor锁计数器+1，+1之后锁计数器变成1，就说明已经被占用，其他线程想要获取，就必须等待锁释放。 线程已经获得monitor的所有权，因为synchronized的可重入性，线程可以再次获得锁，此时计数器再次+1，所以计数器的值不仅仅只有0和1，还可能是更多。 锁计数器当前不为0，是1或者更多，这个时候线程没法获得monitor的所有权，只能等待锁的释放，等计数器变成0，再去竞争锁。 Monitorexit Monitorexit指令就相当于释放锁，当然这里必须是拥有锁才能释放锁。释放的过程比较简单，就是将monitor的计数器减1，如果减完之后，如果不是0，说明刚刚是可重入进来的，线程继续拥有monitor所有权；如果变成0，就说明当前线程已经释放锁，不再拥有monitor的所有权，这也意味着刚刚被阻塞的线程会再次尝试获取锁。 可重入原理 一个线程拿到一把锁之后，如果还想进入由这把锁控制的其他方法，那么它可以直接进入。 可重入原理是利用加锁计数器来实现的。 JVM跟踪计数 首先每个对象都自动的含有一把锁，JVM负责跟踪对象被加锁的次数。 递增 线程第一次给对象加锁，计数器会从0变成1，每当这个相同的线程在此对象再次获取锁时，计数器会递增，当然当前已经获取了锁的线程，才能继续在这个对象上多次获取这把锁。 递减 当任务离开时，计数递减，当计数为0时，锁被完全释放。 可见性原理可见性原理：Java内存模型我们先简要的了解一下java内存模型，下图所表达的是两个线程如果想要通信，它们是如何做到的 可以看到线程A和线程B都有一个本地内存，它们是将主内存中的数据变量复制一份放到自己的本地内存，那它们是如何通信呢？ 线程A需要将自己本地内存的共享变量副本写入主内存，主内存是线程通信的桥梁 主内存中数据更新后，线程B再从主内存中读取，此时线程B就能读取到A更新后的变量数据 可见性原理核心：一旦一个方法或者代码块被synchronized修饰，在进入这个方法或代码块时，被锁定的对象的数据是从主内存中读取；那么它在执行完毕之后，被锁住的对象做的任何修改都要在释放锁之前，从线程内存写回到主内存中。 所以每一次synchronized执行的数据都是最新的，每一次执行都是可靠的，它保证了可见性。 Synchronized的缺陷效率低 锁的释放情况少 synchronized锁的释放情况只有两种：正常执行完毕以及抛出异常。而如果锁不释放，其他处于阻塞的线程只能干巴巴的等着。当在执行IO或sleep等比较费时间的操作时，其他线程只能等很久，这是非常不好的，不过lock可以避免这种情况。 试图获得锁时，不能设定超时 不能中断一个正在试图获取锁的线程 不够灵活（读写锁更灵活） 加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的 例如读写锁，读数据不加锁，写数据加锁，因为读的时候不会嗲来风险，这样可以大大提高效率 无法知道是否成功获取到锁 Lock接口 关于synchronized的缺陷，在Lock中得到了很好的解决 我们来看一下Lock接口的源码，了解一下它的方法： 1234567891011121314151617181920public interface Lock &#123; //加锁 void lock(); //加锁，能够响应中断 void lockInterruptibly() throws InterruptedException; //尝试获取锁，返回boolean boolean tryLock(); //尝试获取锁，设置超时时间，返回boolean boolean tryLock(long time, TimeUnit unit) throws InterruptedException; //释放锁 void unlock(); //与条件相关的，处理线程的接口，这里不做展开 Condition newCondition();&#125; 在本例中，需要特别注意的是 lock()/ tryLock()/ boolean tryLock(long time, TimeUnit unit)/ unlock() ,这四个方法，这也是Lock常用的四个方法。 关于lockInterruptibly()，它比较特殊，当通过这个方法去获取锁时，如果其他线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。 面试常见问题1. synchronized使用注意点 锁对象不可为空：作为锁的对象必须实例过的，或者通过其他方法创建的，不能是一个空对象。因为锁的信息是保存在对象的对象头中的，如果没有对象就更没有对象头了，那么这把锁是不能工作的。 作用域不宜过大：可以并行的代码，要尽量并行，我们加锁也只是为了保证线程的安全，不过将本可以并行的代码串行，这就大大降低了程序运行效率，也有违高并发编程的初衷。 要注意避免死锁 2. 如何选择Lock和synchronized 如果可以，尽量不要使用这两个，可以使用java.util.concurrent包中各种各样的工具类，例如CountDownLatch等，使用这些类不需要我们自己去做同步工作，更方便快捷 如果synchronized适用我们的程序，可以优先选择它，因为它可以减少我们的代码量，也就减少了出错的机率 如果我们特别需要用到Lock的独有的特性的时候，我们才用它 选择思想策略：避免出错 优先选择现成有的工具类 没有现成的类我们就用synchronized 需要用到Lock特性，我们才去使用Lock 3. 多线程访问同步方法的各种情况可以看看前面介绍的内容，这是很重要的一部分。 思考题1. 多个线程等待同一个synchronized锁的时候，JVM如何选择下一个获取锁的线程是哪个？2.Synchronized使得同时只有一个线程可以运行，性能较差，有什么办法可以提升性能？ 优化使用范围 使用其他类的锁 我想更灵活地控制锁的获取和释放（现在释放锁的时机都被规定死了），怎么办？4. 什么是锁的升级、降级？什么是JVM里的偏斜锁、轻量级锁、重量级锁？总结1. 一句话介绍synchronized:JVM会自动通过使用monitor来加锁和解锁，保证了同时只有一个i小鹌鹑可以执行指定代码，从而保证了线程安全，同时具有可重入和不可中断的性质 2. synchronized的作用、地位、不控制并发的后果 3. 两种用法：对象锁和类锁 4. 多线程访问同步方法的7种情况：是否是static、Synchronized方法等 5. Synchronized的性质：可重入、不可中断 6. 原理：加解锁原理、可重入原理、可见性原理 7. Synchronized的缺陷：效率低、不够灵活、无法预判是否获取到锁]]></content>
      <categories>
        <category>JAVA学习笔记</category>
      </categories>
      <tags>
        <tag>Java关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习、工作中所遇到的问题与解决办法]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E3%80%81%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%89%80%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</url>
    <content type="text"><![CDATA[##学习、工作中所遇到的问题与解决办法 2019-08-26idea链接数据库报错报错信息如下： 12Connection to hzero_purchase failed.[08001] Could not create connection to database server. Attempted reconnect 3 times. Giving up. 此时的数据库设置都是正确的，时由于时区的问题，导致数据库连接失败，将数据库连接url改为： jdbc:mysql://localhost:3306/hzero_purchase?serverTimezone=GMT 此时数据库连接正常，问题解决。 Error creating bean with name ‘xxxxController’ Could not autowire field 错误 原因分析 bean不能创建不能自动装载一定出在配置问题上 解决步骤 检查 dao层 service层 controller层有没有加注解 如果没有加上一般就Ok了 如果加了 请看第二步 检查 添加了注解dao层service层controller层对应的包有没有添加进针对这些注解的包扫描中 如果没有 加上就Ok(在spring的配置文件中检查) 打开spring-context.xml配置文件 找到class为org.mybatis.spring.mapper.MapperScannerConfigurer的bean 在name为basePackage的property 在对应的value下添加你的包就行了 2019-09-19]]></content>
      <categories>
        <category>问题总结</category>
      </categories>
      <tags>
        <tag>问题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习总结]]></title>
    <url>%2FSpring%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[Spring学习总结Spring简介 Spring是一个开源的设计层面框架，它解决的是业务逻辑层和其他层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson创建。简单来说，Spring是一个分层的JavaSE/EE full-stack(一栈式) 轻量级开源框架。 J2EE三层架构体系 表现层 view，典型代表：Strusts，Spring MVC 业务层 Service，主要功能是业务处理、功能逻辑、事务控制 IOC、AOP 持久层 dao，mybatis、hibernate、jdbc 轻量级Spring的出现取代了EJB的臃肿、低效、繁琐复杂、脱离现实。 Spring体系结构 IOCIOC介绍 IOC其是一种设计思想，将创建对象的权利交给Spring，由IOC统一加载和管理，让Spring去管理对象生命周期，极大的解决了程序耦合性高的问题。 IOC思想前瞻IOC的核心思想在于，资源不由使用资源的双方管理，而由不使用资源的第三方管理，这可以带来很多好处： 资源集中管理，实现资源的可配置和易管理 降低了使用资源双方的依赖程度，也就是我们说的耦合度。比如说甲方要达成某种目的不需要直接依赖乙方，它只需要达到的目的告诉第三方机构就可以了。 举个栗子： ​ 比如甲方需要一双袜子，而乙方它卖一双袜子它要把袜子卖出去，并不需要自己去直接找到一个买家来完成袜子的卖出。它也只需要找第三方，告诉别人我要卖一双袜子。这样甲乙双方进行交易活动，都不需要自己直接去找卖家，相当于程序内部开放接口，卖家由第三方作为参数传入。甲乙互相不依赖，而且只有在进行交易活动的时候，甲才和乙产生联系。反之亦然。 ​ 这样做什么好处么呢？甲乙可以在对方不真实存在的情况下独立存在，而且保证不交易时候无联系，想交易的时候可以很容易的产生联系。甲乙交易活动不需要双方见面，避免了双方的互不信任造成交易失败的问题。因为交易由第三方来负责联系，而且甲乙都认为第三方可靠。那么交易就能很可靠很灵活的产生和进行了，这就是IOC的核心思想甲乙双方将不在相互依懒！ Spring IOC 容器 Spring IOC容器有两种BeanFactory和ApplicationContext，BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身。ApplicationContext 面向使用 Spring 框架的开发者，几乎所有的应用场合我们都直接使用 ApplicationContext 而非底层的 BeanFactory。 BeanFactory BeanFactory 接口位于类结构树的顶端 ，IOC容器所设定的最基本功能规范。 BeanFactory最主要的方法就是getBean(String beanName)，这个方法从容器中返回特别名称的Bean。 BeanFactory的三个子接口： HierarchicalBeanFactory：提供父容器的访问功能 ListableBeanFactory：提供了批量获取Bean的方 AutowireCapableBeanFactory：在BeanFactory基础上实现对已存在实例的管解析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public interface BeanFactory &#123; /** * 获取产生对象的FactoryBean * 如：myObject是一个FactoryBean，使用&amp;myObject得到的是FactoryBean */ String FACTORY_BEAN_PREFIX = "&amp;"; /** * 获取IoC容器中管理的bean * @param name * @return * @throws BeansException */ Object getBean(String name) throws BeansException; /** * 判断容器是否含有指定名称的bean * @param name * @return */ boolean containsBean(String name); /** * 检查指定名称的bean是否是单例（可以在BeanDefinition中指定） * @param name * @return * @throws NoSuchBeanDefinitionException */ boolean isSingleton(String name) throws NoSuchBeanDefinitionException; /** * 检查指定名称的bean是否是prototype类型（可以在BeanDefinition中指定） * @param name * @return * @throws NoSuchBeanDefinitionException */ boolean isPrototype(String name) throws NoSuchBeanDefinitionException; /** * 检查指定名称的bean的Class类型是否是特定Class类型 * @param name * @param targetType 用户指定 * @return * @throws NoSuchBeanDefinitionException */ boolean isTypeMatch(String name, Class targetType) throws NoSuchBeanDefinitionException; /** * 查询指定名称bean的Class类型 * @param name * @return * @throws NoSuchBeanDefinitionException */ Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; /** * 查询指定名称bean的所有别名（用户在BeanDefinition中指定的） * @param name * @return */ String[] getAliases(String name);&#125; ApplicationContext12ApplicationContext app = new ClassPathXmlApplicationContext("配置文件.xml"); 类名 对象名 =(类名)app.getBean(" "); 从 ApplicationContext 的继承机构可以看到，ApplicationContext 继承了BeanFactory，也就是说，ApplicationContext拥有BeanFactory的全部功能。ApplicationContext 是通过将容器的功能委派给DefaultListableBeanFactory来实现。除了继承BeanFactory，还有ResourceLoader、EnvironmentCapable、ApplicationEventPublisher、MessageSource等接口，也就说明ApplicationContext 除了容器的功能外，还囊括了资源的处理、环境、事件发布、国际化等。 示例12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 若没写id，则默认为com.test.Man#0,#0为一个计数形式 --&gt; &lt;bean id="man" class="com.test.Man"&gt;&lt;/bean&gt;&lt;/beans&gt;public class Test &#123; public static void main(String[] args) &#123; //加载项目中的spring配置文件到容器 //ApplicationContext context = new ClassPathXmlApplicationContext("resouces/applicationContext.xml"); //加载系统盘中的配置文件到容器 ApplicationContext context = new FileSystemXmlApplicationContext("E:/Spring/applicationContext.xml"); //从容器中获取对象实例 Man man = context.getBean(Man.class); man.driveCar(); &#125;&#125; DI(依赖注入) IOC重点是如何在系统运行中动态向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。 比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 Spring我们就只需要告诉Spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，Spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由 Spring注入到A中的，依赖注入的名字就这么来的。 那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，Spring就是通过反射来实现注入的。 DI关键点理解DI的关键是：依赖。为什么需要依赖，谁注入谁，注入了什么。 应用程序依赖于IOC容器，为什么需要依赖：应用程序需要IOC容器来提供对象需要的外部资源比如对数据库操作的对象，IOC容器注入这个，应用程序依赖这个对象 IOC和DI有什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：依赖注入，相对IOC 而言，依赖注入明确描述了被注入对象依赖IOC容器配置依赖对象！ Spring装配bean的三种方式 构造器注入 使用setter方法注入（推荐） 接口注入 基于注解的方式1234567891011121314@Component：可以用于注册所有bean@Repository：主要用于注册dao层的bean@Controller： 主要用于注册控制层的bean@Service： 主要用于注册服务层的bean@Resource：java的注解，默认以byName的方式去匹配与属性名相同的bean的id，如果没有找到就会以byType的方式查找，如果byType查找到多个的话，使用@Qualifier注解（spring注解）指定某个具体名称的bean。@Autowired：spring注解，默认也是以byName的方式去匹配与属性名相同的bean的id，如果没有找到，就通过byType的方式去查找，如果查找到多个，用@Qualifier注解限定具体使用哪个。@Autowiredprivate IUserDao userDao;但是如果IUserDao有多个实现类则需要：@Autowired@Qualifier("指定具体实现")private IUserDao userDao; AOP 在软件业，AOP为Aspect Oriented Programming的缩写，意为：[面向切面编程]，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，使函数式编程降低，提高程序的可重用性，同时提高了开发的效率。 spring术语 切面：拦截器类，其中会定义切点以及通知 通知：切面中的方法，包括： 前置通知：在动态代理反射原先方法前调用的方法 后置通知：在动态代理反射完原有方法后调用的方法 返回通知：如果方法正常执行，在调用完后置通知后，就调用返回通知 异常通知：如果方法出现异常，在调用完后置通知后，就调用异常通知 环绕通知：可以决定是否调用目标方法，同时可以控制方法的返回 对象 引入：往代理对象中添加新的方法，但是新的方法不会被拦截 切点：即定义需要拦截的方法的特征，可以通过正则表达式匹配，也可以通过类的全限定名 连接点：需要拦截的方法 织入：生成代理对象并将切面内容嵌入流程中，将切面内容嵌入到流程中是什么意思呢？例如现在定义了前置通知，那么代理对象在调用被代理对象的方法之前就会调用前置通知 示例12345678910111213141516171819202122232425@Aspectpublic class UserInterceptor &#123; @Pointcut("execution( * org.srm.practice.service.*.*(..))") public void user() &#123; &#125; @Before("user()") public void sayHello() &#123; System.out.println("前置"); &#125; @After("user()") public void sayGoodbey() &#123; System.out.println("后置"); &#125; @Around("user()") public void sayAround(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println("环绕通知..环绕前"); pjp.proceed();//执行方法 System.out.println("环绕通知..环绕后"); &#125;&#125; 事物 Spring支持编程式事务管理和声明式事务管理两种方式。 编程式事务编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，Spring推荐使用TransactionTemplate。 声明式事务声明式事务管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中 事务隔离级别 隔离级别是指若干个并发的事务之间的隔离程度。 TransactionDefinition 接口中定义了五个表示隔离级别的常量： TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。 TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。 TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。 TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。 TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 事务传播级别 所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。 在TransactionDefinition定义中包括了如下几个表示传播行为的常量： TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。 TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。 TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。 TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 TransactionDefinition.PROPAGATION_REQUIRED。 事务超时,所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。默认设置为底层事务系统的超时值，如果底层数据库事务系统没有设置超时值，那么就是none，没有超时限制。]]></content>
      <categories>
        <category>JAVA学习笔记</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub+hexo搭建个人博客详细教程]]></title>
    <url>%2FGitHub-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[GitHub+hexo搭建个人博客详细教程 前言随着互联网浪潮的翻腾，国内外涌现出越来越多优秀的社交信息分享者，随之优秀的信息分享平台也越来越多，最常见的就是个人博客。GitHub + hexo 是比较受欢迎的一种方式，为什么呢？省钱、简单、快速。如果你也是一个不甘寂寞、喜欢折腾的程序猿（媛），如果你也有过这种想要搭建一个所以自己的博客网站的想法，可以跟着我这篇教程博客一起，它可以让你快速搭建起一个属于自己的个人博客，享受这种从0到1的过程。 概念介绍Hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo是一个基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。我这里选的是GitHub。Hexo的作者是台湾的，对中文支持很友好，可以到 Hexo官网 了解更多细节。 GitHubGitHub是一个代码托管网站和社交编程网站。这里聚集了世界上各路技术牛叉的大牛，和最优秀的代码库。是全球程序员的天堂。因为是国外的，所以界面全是英文。 GitHub PagesGitHub Pages是用来托管 GitHub 上静态网页的免费站点。 Coding Pages和GithubPages功能相同，其对应的Coding平台也可以实现和Github相似的功能。但没有后者那么出名。是香港的公司，也是国内的。部署在codingpages上，在国内访问，速度会快很多。部署在coding上，可以自行查找教程，我这篇博客主讲利用 GitHub 搭建。 看了这些概念，我相信你一定还是一脸懵逼的。但你可以简单理解成下边的的一段话： 利用Hexo和GithubPages/CodingPages搭建博客，实际上就是利用Hexo在本地（你的电脑上）生成一个博客站点，然后利用网络将它传输到Github/Coding上进行拷贝和备份。再由Github和Coding提供的GithubPages/CodingPages服务将博客部署到网上，这样你的博客就可以作为一个独立的站点被别人浏览（正式上线）。同时你也可以在Github和Coding上管理你的博客。 这是我博客的效果：Nine’s Blog 下面正式开始，从零开始搭建属于个人博客。 搭建步骤 环境搭建 安装git 安装node.js 安装Hexo 获取个人网站域名 GitHub创建个人仓库 推送网站 绑定域名 主题及个性化设置 发布文章 图床选择 其他 环境搭建安装Gitgit是一个开源的分布式版本控制系统，用于敏捷高效地处理项目。我们这里需要利用git将我们搭建好的网站推送到 github 上。git安装教程看我的另一篇博客：git安装详细教程（暂未写）。也可以到csdn等技术交流平台上寻找教程。 安装Node.jsHexo基于Node.js，我们需要在本机安装Node.js，下载地址：Download|Node.js 我下载的是node-v10.16.2-x64.msi，下载好之后一路默认安装next就好。注意安装Node.js包括node.js的环境变量配置以及npm的安装。 检查Node.js是否安装成功，打开命令窗口，输入 node -v 检查npm是否安装成功，在命令窗口输入 npm -v 到这里，Hexo的环境就已经全部搭建好了。 安装Hexo安装hexohexo就是我们用于搭建个人博客的框架，这个时候我们需要在我们本地文件夹中创建一个用于博客管理的文件夹，我命名为Blog。hexo框架与以后写作发布的网页等都会保存在这个文件夹中，创建好之后进入文件夹，按住shift，然后鼠标右键-在此处打开命令行 使用npm命令安装Hexo，输入： 1npm install -g hexo-cli 耐心等待安装完成，完成之后，初始化我们的博客，输入： 1hexo init bolg 注意，这些命令都作用于我们刚刚新建的Blog文件夹中。 此时我们检测一下我们网站的雏形，按顺序输入以下三条命令： 123hexo new hello Hexo //新建一篇名为"hello Hexo"的博客hexo g //生成静态文件hexo s //本地部署预览 此时，我们的网站已经初步成型，可以输入 localhost:4000 访问。 我的blog修改过配置，和你们新搭建的略有区别。 hexo常用命令初始化命令 123npm install hexo -g //安装Hexonpm update hexo -g //升级 hexo init //初始化博客 命令简写 1234hexo n "我的博客" = hexo new "我的博客" //新建文章hexo g = hexo generate //生成hexo s = hexo server //启动服务预览hexo d = hexo deploy //部署 其他命令 12345hexo server //Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s //静态模式hexo server -p 5000 //更改端口hexo server -i 192.168.1.1 //自定义 IPhexo clean //清除缓存，若是网页正常情况下可以忽略这条命令 推送网站配置文件介绍上面我们只是在本地预览，接下来要做的就是推送网站，也就是发布网站，让我们的网站在互联网上能被访问到。在设置之前，我们先来看看blog根目录里的_config.yml文件，是我们的站点配置文件，如下图： 进入根目录的themes文件夹的任意主题目录，也有一个_config.yml文件，这个是主题配置文件，如下图： 将hexo与gitHub关联打开blog根目录下的站点配置配置文件_config.yml，修改成下面的样子并保存 这一步其实就是给 hexo d 这个部署命令做相应的配置，让hexo知道你要把blog部署到哪，很显然我们是部署到github仓库里。 然后我们要安装git部署插件，输入以下命令： 1npm install hexo-deployer-git --save 然后我们在输入三条命令： 123hexo clean //清理静态文件hexo g //生成静态文件hexo d //部署 这三条是我们日后写博客经常要用到的命令，其中第三条的 hexo d 就是部署网站命令，d是deploy的缩写，对应到我们刚刚在站点配置文件中的修改。 完成后打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即xxxx.github.io，其中xxxx表示我们的用户名。当然这里有个前提，你是按照用户名.github.io的形式来命名你的仓库。 你就会发现你的博客已经上线了，可以在网络上被访问了。 绑定域名虽然在Internet上可以访问我们的网站，但是网址是GitHub提供的:xxxx.github.io， 而我们想使用我们自己的个性化域名，这就需要绑定我们自己的域名。这里演示的是在阿里云万网的域名绑定，在国内主流的域名代理厂商也就阿里云和腾讯云。登录到阿里云，进入管理控制台的域名列表，找到你的个性化域名，进入解析 然后添加解析 包括添加三条解析记录，192.30.252.153是GitHub的地址，你也可以ping你的 xxxx.github.io 的ip地址，填入进去。第三个记录类型是CNAME，CNAME的记录值是：你的用户名.github.io这里千万别弄错了。 第二步，登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名 点击save保存。 第三步，进入本地博客文件夹 ，进入blog/source目录下，创建一个记事本文件，输入你的域名，对，只要写进你自己的域名即可。如果带有www，那么以后访问的时候必须带有www完整的域名才可以访问，但如果不带有www，以后访问的时候带不带www都可以访问。所以建议，不要带有www： 完成这三步，进入blog目录中，按住shift键右击打开命令行，依次输入： 123hexo cleanhexo ghexo d 这时候打开浏览器在地址栏输入你的个性化域名将会直接进入你自己搭建的网站。 主题及个性化设置更换主题如果你不喜欢Hexo默认的主题，可以更换不同的主题，主题传送门：Themes 我自己使用的是Next主题，可以在blog目录中的themes文件夹中查看你自己主题是什么。现在把默认主题更改成Next主题，在blog目录中（就是命令行的位置处于blog目录）打开命令行输入： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 这是将Next主题下载到blog目录的themes主题下的next文件夹中。 打开站点的_config.yml配置文件，修改主题为next: 打开主题的_config.yml配置文件，不是站点主题文件，找到Scheme Settings next主题有三个样式，我用的是Pisces，你们可以自己试试看，选择你自己喜欢的样式（只需要把行首的#去除，#是注释），选择好后，再次部署网站，hexo g、hexo d，查看效果。选择其他主题，按照上述过程即可实现。 个性化设置如果你没有用next主题，那么以下个性化设置就不用看了。因为它们都是next的配置。 关于next主题的配置，可以参考它的官方文档：next官方文档 关于其他的个性化设置，我的博客所有的个性化都来自这些连接： RSS和High特效 这篇真的厉害了，有30种特效：hexo的next主题个性化教程:打造炫酷网站 主讲第3方服务：配置第三方服务 创建一个菜单页面作为文章目录：hexo下新建页面下如何放多个文章 博客加密：加密插件Github，issue里有解决next主题兼容的方法 版权声明：Hexo博客NexT主题美化之自定义文章底部版权声明 SEO优化：Hexo NexT 主题SEO优化指南 评论系统：hexo+next使用Valine评论系统 插件库：Hexo插件 图床选择关于图床，免费的图床有很多，但是免费的图床总会有很多问题，例如图片链接经常会失效等。 我这里也推荐一个还算好用的免费图床：聚合图床 建议还是花点钱弄个付费的，也不贵。我选择的是 阿里云OSS ，很便宜，九块钱一年，超出按留流量收费。 另外还有一款超级好用的图床上传工具：PicGo ，真的是十分好用了。 当然还有很多其他好用的图床，阿里云和腾讯云都差不多，SM.MS 等也还可以，总之我觉得收费的省心一些，当然你也可以说：“我不要你觉得，我要我觉得”，哈哈。 其他我踩过的坑 域名买.top的就可以，土豪请随意 修改配置文件，很容易搞错路径，因为这个站点内同名的文件在很多路径下都有，例如_config.yml 如果安装hexo过程中或者之前有报错，建议你重装。一旦出错了，基本就是你的操作问题了，而且很难发现、解决，解决错误的时间可以重装很多次了 域名的绑定，关于添加解析，很容易出错！！有的博主说是三条，有的博主说是两条，我是添加了三条的，如果你遇到什么问题，可以试试两条，百度一下解决方案 我的建议 个性固然好，但是在设置的时候一定要细心，这些都是要打开代码文件去修改的，如果本机装有IDEA，最好用它来编辑，没装的话IDEA的话，Sublime、EditPlus也行 图床选择要谨慎，建议选择知名图床，有很小的图床经常会失效，另外图片文件一定要在本地留有备份 个性化可以让你的博客看起来高大上许多，但最重要的还是我们持续的价值输出，坚持写博客才是真理，不要忘记我们搭建博客的初心（当我知道很多小伙伴和我一样，就是喜欢折腾，哈哈） 博客的源文件，也可以托管到github上，特别是博文对应得md文件，一定别弄丢了，整个站点文件都托管的话，可以多台电脑去管理你的博客 国内访问GitHub得速度不理想，可以将博客同时部署到GitHub和coding，提高国内访问速度]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud]]></title>
    <url>%2FSpring%20Cloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html</url>
    <content type="text"><![CDATA[Spring Cloud Spring Cloud 微服务架构 Spring Cloud 网关 Spring Cloud 服务发现 Spring Cloud 其他组件 Spring Cloud 微服务架构什么是微服务 集群：通过一组集成得计算机软件和/或硬件连接起来高度紧密得协作完成计算机工作。 高性能:通过多台计算机完成统一工作，分摊压力，达到跟高得效率 高可用：两机或多机工作内容、过程完全一致，可以互相顶替 分布式：一组计算机通过网络互相连接传递消息与通信并协调他们之间的行为而形成得系统，组件之间彼此进行交互以实现一个共同得目标 低耦合：模块之间相互独立，便于扩展，提高资源利用效率 高吞吐：功能差分，分散到不同得模块执行 集群和分布式并不冲突 CAP理论：强一致性（C）、极致可用性（A）、分区容错性（P） 什么是 Spring Cloud​ 当我们了解集群和分布式这两个概念之后，我们来看看什么是Spring Cloud，在这之前我们先回顾一下Spring Boot，Spring Boot是比较合适基于spring的快速开发，用于搭建一个单体的小型项目非常方便。这里为什么提Spring boot呢？因为Spring Cloud就是基于Spring Boot实现的。 Spring Cloud提供了分布式系统的一整套的解决方案 Spring Cloud提供了快速构建分布式系统中的一些常见模式的组件 ps：前面对集群和分布式讲解是从概念上进行理解的，当我们落实到实现上时，可能会约到各种各样的问题，随着分布式架构的发展，慢慢的有一些优秀的架构设计，还有一些组件就会被广泛的应用，Spring Cloud就为常见的架构提供一些通用的组件。 Spring Cloud 组件下面我们通过一个图来了解Spring Cloud为分布式系统提供的组件 服务​ 假设我们需要利用Spring Boot开发一个单独的系统，但是随着我们系统的开发，一个单体的应用程序可能会变得非常的臃肿，整个应用程序会变得非常庞大，代码量和功能都会变得很多。这时我们按照分布式的概念将服务进行拆分，如上图，此时出现了橙、蓝、黄三个服务，每个服务只专注自己的功能。 注册中心​ 但是当我们拆分为多个服务之后，服务之间难免会出现互相通信的时候，这个时候我们可能需要在服务中去维护其他服务的ip，这就略显麻烦了。当我们在服务器集群中使用容器化部署的时候我们就会遇到一个更加灾难性的问题——我们每次部署的ip可能会变化，那么这个ip的维护工作就会变得非常繁琐。为了解决这个问题，Spring Cloud提供了一个组件叫注册中心，有了注册中心这个组件之后，每个服务不再像之前一样在服务内去维护其他服务的ip，而是将自己的ip维护到注册中心，这样注册中心就会有一个完整的服务列表，如果需要进行服务间的调用，我们只需要去注册中心拉去服务列表，去获取对应服务的ip就可以了。 负载均衡——Ribbon​ 解决了最基本的通信问题之后，随着系统的不断扩展，我们会发现即使服务进行了划分，我们某个服务可能会遇到性能上的瓶颈，这时我们想到一个办法——将调用比较频繁的服务进行集群部署。例如上图，将第一个服务部署成两个节点，此时系统的压力会得到一定的缓解。但是这个时候我们又遇到了一个新的问题——服务件调用的时候我们需要进行一个决策。例如第二个服务和第三个服务需要调用第一个服务，但是第一个服务有两个节点，我们需要对集群的调用做负载均衡，不然调用请求集中发到一个节点上，这样还是会导致这个节点服务器压力特别大。这个时候，Spring Cloud为我们提供了一个组件——Ribbon，这个组件就是为了处理一个服务多实例下的负载均衡。 熔断限流——Hystrix​ 当我们有了负载均衡之后，我们的系统能正常运行，但是这样还不够，比如我们做了集群和负载均衡，第一个服务的压力还是非常大，这时服务间的调用可能会有阻塞，当服务调用发生了阻塞，又无节制的去向第一个服务发送请求，很可能会导致第一个服务宕机。Spring Cloud为了避免这种情况为我们提供了一个新的组件——Hystrix。这个组件的功能是熔断和限流，也就是当我们的请求无法得到响应的时候，它会中断我们的请求，并限制我们的请求调用，通过这种机制我们就能避免系统长时间无响应、服务器压力过高。 API网关​ 在有了熔断和限流之后，我们系统的内部组件已经比较完整了，但这时我们又会遇到一个微服务带来的问题——用户通过web端或客户端访问我们的系统时，它需要访问多个服务，此时我们就需要在web端或者客户端去维护我们多个服务的服务信息，这与服务去维护其他服务信息一样，是非常让人头疼的。除了这个问题之外，我们还会遇到另一个问题，通常情况下，我们的系统都系统做认证和授权，针对这种分布式的场景，每个服务还需要自己去实现权限校验的功能，也就是说无形中，我们分布式系统实现的代价就高了。为了解决这个问题，Spring Cloud引入了一个组件——API网关，API网关也是注册到注册中心，它的功能就是统一对外的入口，请求不再访问指定的服务，而是同意从网关访问，网关会通过一系列的过滤，最终将请求转发到对应的服务上。 授权服务​ 我们可以统一入口，那么我们也可以做一些其他的统一操作，比如授权，我们可以在网关中添加权限过滤，这样就不需要在每个服务中单独做服务校验了。 Spring Cloud 常用组件通过上面的介绍，我们了解了 Spring Cloud 为我们提供的一些组件，也了解了 Spring Cloud 的架构，下面我们进行总结： 服务治理：Spring Cloud Eureka 负载均衡：Spring Cloud Ribbon 熔断限流：Spring Cloud Hystrix 服务调用：Spring Cloud Feign 发起一个请求，原始的情况是使用httpclient，或者是采用spring封装过的resttemplate，但是这两个还是相对比较繁琐的，Feign的存在就是为了简化内部调用，它提供了声明性来提供内部调用，不需要自己再去实现http请求，我们只需要定义一个接口，它就能自动帮我们封装成一个http请求，Feign的实现也是基于resttemplate 网关服务：Spring Cloud Zuul]]></content>
      <categories>
        <category>JAVA学习笔记</category>
      </categories>
      <tags>
        <tag>springCloud</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello Hexo]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
